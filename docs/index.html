<html><style>
html {
   background-color: #16191a;
}

body {
   background-color: #181a1b;
   margin: auto;
   max-width: 70em;
   width: 90%;
   padding: 32px;
   font-family: Helvetica, Arial, sans-serif;
   color: #e8e6e3;
}

a {
   text-decoration: none;
   color: #3391ff;
}

h2 {
   color: #117dee;
}

</style><body><table width="100%"><tbody><tr><td valign=top><h4>ltreesitter</h4><p><a href="#_get_registry_entry">_get_registry_entry</a><br><a href="#load">load</a><br><a href="#require">require</a><br></p><h4>Cursor</h4><p><a href="#Cursor.current_field_name">Cursor.current_field_name</a><br><a href="#Cursor.current_node">Cursor.current_node</a><br><a href="#Cursor.goto_first_child">Cursor.goto_first_child</a><br><a href="#Cursor.goto_next_sibling">Cursor.goto_next_sibling</a><br><a href="#Cursor.goto_parent">Cursor.goto_parent</a><br><a href="#Cursor.reset">Cursor.reset</a><br></p><h4>Node</h4><p><a href="#Node.byte_range">Node.byte_range</a><br><a href="#Node.child">Node.child</a><br><a href="#Node.child_by_field_name">Node.child_by_field_name</a><br><a href="#Node.child_count">Node.child_count</a><br><a href="#Node.children">Node.children</a><br><a href="#Node.create_cursor">Node.create_cursor</a><br><a href="#Node.end_byte">Node.end_byte</a><br><a href="#Node.end_point">Node.end_point</a><br><a href="#Node.is_extra">Node.is_extra</a><br><a href="#Node.is_missing">Node.is_missing</a><br><a href="#Node.is_named">Node.is_named</a><br><a href="#Node.name">Node.name</a><br><a href="#Node.named_child">Node.named_child</a><br><a href="#Node.named_child_count">Node.named_child_count</a><br><a href="#Node.named_children">Node.named_children</a><br><a href="#Node.next_named_sibling">Node.next_named_sibling</a><br><a href="#Node.next_sibling">Node.next_sibling</a><br><a href="#Node.prev_named_sibling">Node.prev_named_sibling</a><br><a href="#Node.prev_sibling">Node.prev_sibling</a><br><a href="#Node.source">Node.source</a><br><a href="#Node.start_byte">Node.start_byte</a><br><a href="#Node.start_point">Node.start_point</a><br><a href="#Node.type">Node.type</a><br></p></td><td valign=top><h4>Parser</h4><p><a href="#Parser.parse_string">Parser.parse_string</a><br><a href="#Parser.query">Parser.query</a><br><a href="#Parser.set_timeout">Parser.set_timeout</a><br></p><h4>Query</h4><p><a href="#Query.capture">Query.capture</a><br><a href="#Query.match">Query.match</a><br></p><h4>Tree</h4><p><a href="#Tree.copy">Tree.copy</a><br><a href="#Tree.edit">Tree.edit</a><br><a href="#Tree.root">Tree.root</a><br></p></td></tr></tbody></table><br><br><br><br><br><br><br><br><br><br><h2><a id="_get_registry_entry"><code>_get_registry_entry: function(): table </code></a></h2><p>ltreesitter uses a table in the Lua registry to keep references alive and prevent Lua's garbage collection from collecting things that the library needs internally.<br>   The behavior nor existence of this function should not be relied upon and is included strictly for memory debugging purposes<br><br>   Though, if you are looking to debug a segfault/garbage collection bug, this is a useful tool in addition to the lua inspect module</p><br><h2><a id="load"><code>load: function(file_name: string, language_name: string): Parser, string </code></a></h2><p>Load a parser from a given file<br><br>   On unix this uses dlopen, so if a path without a path separator is given, dlopen has its own path's that it will search for your file in.<br>   So if in doubt use a file path like<br>   <pre><br>   local my_parser = ltreesitter.load("./my_parser.so", "my_language")<br>   </pre><br><br>   * Currently this does not work on Windows<br>   (The entire library doesn't work on Windows since this is one of the entry points to any of the functionality)</p><br><h2><a id="require"><code>require: function(language_name: string): Parser </code></a></h2><p>Search <code>package.cpath</code> for a parser with the filename <code>language_name.so</code> (or <code>.dll</code> on Windows) and try to load the symbol <code>tree_sitter_language_name</code><br>   Like the regular <code>require</code>, this will error if the parser is not found or the symbol couldn't be loaded. Use either <code>pcall</code> or <code>ltreesitter.load</code> to not error out on failure.<br><br>   <pre><br>   local my_parser = ltreesitter.require("my_language")<br>   my_parser:parse_string(...)<br>   -- etc.<br>   </pre><br><br>   * Currently this does not work on Windows<br>   (The entire library doesn't work on Windows since this is one of the entry points to any of the functionality)</p><br><br><h2><a id="Cursor.current_field_name"><code>Cursor.current_field_name: function(Cursor): string </code></a></h2><p>Get the field name of the current node under the cursor</p><br><h2><a id="Cursor.current_node"><code>Cursor.current_node: function(Cursor): Node </code></a></h2><p>Get the current node under the cursor</p><br><h2><a id="Cursor.goto_first_child"><code>Cursor.goto_first_child: function(Cursor): boolean </code></a></h2><p>Position the cursor at the first child of the current node</p><br><h2><a id="Cursor.goto_next_sibling"><code>Cursor.goto_next_sibling: function(Cursor): boolean </code></a></h2><p>Position the cursor at the sibling of the current node</p><br><h2><a id="Cursor.goto_parent"><code>Cursor.goto_parent: function(Cursor): boolean </code></a></h2><p>Position the cursor at the parent of the current node</p><br><h2><a id="Cursor.reset"><code>Cursor.reset: function(Cursor, Node) </code></a></h2><p>Position the cursor at the given node</p><br><br><h2><a id="Node.byte_range"><code>Node.byte_range: function(Node): number, number </code></a></h2><p>Get both the start and end bytes of the source string<br>   for easy use with string.sub<br>   <pre> print( source_string:sub( my_node:byte_range() ) ) </pre></p><br><h2><a id="Node.child"><code>Node.child: function(Node, idx: number): Node </code></a></h2><p>Get the node's idx'th child (0-indexed)</p><br><h2><a id="Node.child_by_field_name"><code>Node.child_by_field_name: function(Node, string): Node </code></a></h2><p>Get a node's child given a field name</p><br><h2><a id="Node.child_count"><code>Node.child_count: function(Node): number </code></a></h2><p>Get the number of children a node has</p><br><h2><a id="Node.children"><code>Node.children: function(Node): function(): Node </code></a></h2><p>Iterate over a node's children</p><br><h2><a id="Node.create_cursor"><code>Node.create_cursor: function(Node): Cursor </code></a></h2><p>Create a new cursor at the given node</p><br><h2><a id="Node.end_byte"><code>Node.end_byte: function(Node): number </code></a></h2><p>Get the byte of the source string that the given node ends at</p><br><h2><a id="Node.end_point"><code>Node.end_point: function(Node): Point </code></a></h2><p>Get the row and column of where the given node ends</p><br><h2><a id="Node.is_extra"><code>Node.is_extra: function(Node): boolean </code></a></h2><p>Get whether or not the current node is missing</p><br><h2><a id="Node.is_missing"><code>Node.is_missing: function(Node): boolean </code></a></h2><p>Get whether or not the current node is missing</p><br><h2><a id="Node.is_named"><code>Node.is_named: function(Node): boolean </code></a></h2><p>Get whether or not the current node is named</p><br><h2><a id="Node.name"><code>Node.name: function(Node): string </code></a></h2><p>Returns the name of a given node<br>   <pre><br>   print(node) -- => (comment)<br>   print(node:name()) -- => comment<br>   </pre></p><br><h2><a id="Node.named_child"><code>Node.named_child: function(Node, idx: number): Node </code></a></h2><p>Get the node's idx'th named child (0-indexed)</p><br><h2><a id="Node.named_child_count"><code>Node.named_child_count: function(Node): number </code></a></h2><p>Get the number of named children a node has</p><br><h2><a id="Node.named_children"><code>Node.named_children: function(Node): function(): Node </code></a></h2><p>Iterate over a node's named children</p><br><h2><a id="Node.next_named_sibling"><code>Node.next_named_sibling: function(Node): Node </code></a></h2><p>Get a node's next named sibling</p><br><h2><a id="Node.next_sibling"><code>Node.next_sibling: function(Node): Node </code></a></h2><p>Get a node's next sibling</p><br><h2><a id="Node.prev_named_sibling"><code>Node.prev_named_sibling: function(Node): Node </code></a></h2><p>Get a node's previous named sibling</p><br><h2><a id="Node.prev_sibling"><code>Node.prev_sibling: function(Node): Node </code></a></h2><p>Get a node's previous sibling</p><br><h2><a id="Node.source"><code>Node.source: function(Node): string </code></a></h2><p>Get the substring of the source that was parsed to create <code>Node</code></p><br><h2><a id="Node.start_byte"><code>Node.start_byte: function(Node): number </code></a></h2><p>Get the byte of the source string that the given node starts at</p><br><h2><a id="Node.start_point"><code>Node.start_point: function(Node): Point </code></a></h2><p>Get the row and column of where the given node starts</p><br><h2><a id="Node.type"><code>Node.type: function(Node): string </code></a></h2><p>Get the type of the given node</p><br><br><h2><a id="Parser.parse_string"><code>Parser.parse_string: function(Parser, string, Tree): Tree </code></a></h2><p>Uses the given parser to parse the string<br><br>   If Tree is provided then it will be used to create a new updated tree<br>   (but it is the responsibility of the programmer to make the correct <code>Tree:edit</code> calls)<br><br>   Could return nil if the parser has a timeout</p><br><h2><a id="Parser.query"><code>Parser.query: function(Parser, string): Query </code></a></h2><p>Create a query out of the given string for the language of the given parser</p><br><h2><a id="Parser.set_timeout"><code>Parser.set_timeout: function(Parser, number) </code></a></h2><p>Sets how long the parser is allowed to take in microseconds</p><br><br><h2><a id="Query.capture"><code>Query.capture: function(Query, Node): function(): Node, string </code></a></h2><p>Iterate over the captures of a given query in <code>Node</code>, <code>name</code> pairs<br>   Since queries can capture unnamed nodes, the name is given second to prevent Lua from thinking the iteration is over<br><br>   <pre><br>   local q = parser:query[[ (comment) @my_match ]]<br>   for capture, name in q:capture(node) do<br>      print(capture, name) -- => (comment), "my_match"<br>   end<br>   </pre></p><br><h2><a id="Query.match"><code>Query.match: function(Query, Node): function(): Match </code></a></h2><p>Iterate over the matches of a given query<br><br>   <pre><br>   local q = parser:query[[ (comment) @my_match ]]<br>   for match in q:match(node) do<br>      print(match.my_match)<br>   end<br>   </pre><br><br>   The match object is a record populated with all the information given by treesitter<br>   <pre><br>   type Query.Match = record<br>      id: number<br>      pattern_index: number<br>      capture_count: number<br>      captures: {string|number:Node}<br>   end<br>   </pre></p><br><br><h2><a id="Tree.copy"><code>Tree.copy: function(Tree): Tree </code></a></h2><p>Creates a copy of the tree. Tree-sitter recommends to create copies if you are going to use multithreading since tree accesses are not thread-safe, but copying them is cheap and quick</p><br><h2><a id="Tree.edit"><code>Tree.edit: function(Tree, TreeEdit) </code></a></h2><p>Create an edit to the given tree</p><br><h2><a id="Tree.root"><code>Tree.root: function(Tree): Node </code></a></h2><p>Returns the root node of the given parse tree</p></body></html>